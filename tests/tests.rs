extern crate cbindgen;

use std::path::{Path, PathBuf};
use cbindgen::*;
use std::{env, fs};
use std::process::Command;

fn run_cbindgen(path: &Path, output: &Path, language: Language, style: Option<Style>) {


    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    {
        let mut program = PathBuf::from(crate_dir);
        program.push("target");
        program.push("debug");
        program.push("cbindgen");

        //    if !program.exists() {
        //        throw_new!(format!("program does not exist. {}", program));
        //    }

        let mut command = Command::new(program);
        match language {
            Language::Cxx => {},
            Language::C => {
                command.arg("--lang").arg("c");
            },
        }
        match style {
            None => {},
            Some(s) => {
                match s {
                    Style::Both => { command.arg("--style").arg("both"); },
                    Style::Tag => { command.arg("--style").arg("tag"); },
                    Style::Type => { command.arg("--style").arg("type"); },
                }
            },
        }
        command.arg("-o").arg(output);

        // TODO verify

        let mut config = path.clone().to_path_buf();
        config.set_extension("toml");
        if config.exists() {
            command.arg("--config").arg(config);
        }

        command.arg(path);
        command.output()
            .expect("failed to execute process");

        compile(output, language);

        if output.exists() {
            fs::remove_file(output).unwrap();
        }
    }

}

fn compile(output: &Path, language: Language) {
    {
        let cc = match env::var("CC") {
            Ok(val) => { val },
            Err(_) => {
                match language {
                    Language::Cxx => { "g++".to_string() },
                    Language::C => { "gcc".to_string() },
                }
            },
        };

        let mut object = output.to_path_buf();
        object.set_extension("o");

        let mut command = Command::new(cc);
        command.arg("-D").arg("DEFINED");
        command.arg("-c").arg(output);
        command.arg("-o").arg(&object);

        command.output()
            .expect("failed to compile");

        if object.exists() {
            fs::remove_file(object).unwrap();
        }
    }
}

fn run_compile_test(name: &'static str, path: &Path, language: Language, style: Option<Style>) {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let mut output = PathBuf::from(crate_dir);
    output.push("tests");
    output.push("expectations");
    match &style {
        None => {},
        Some(s) => {
            match s {
                Style::Both => {
                    output.push("both");
                },
                Style::Tag => {
                    output.push("tag");
                },
                Style::Type => {},
            }
        },
    }
    match language {
        Language::Cxx => {
            output.push(format!("{}.cpp", name));
        },
        Language::C => {
            output.push(format!("{}.c", name));
        },
    }

    run_cbindgen(path, &output, language, style);
}

fn test_file(name: &'static str, filename: &'static str) {
    let test = Path::new(filename);
    for style in &[Style::Type, Style::Tag, Style::Both] {
        run_compile_test(name, &test, Language::C, Some(style.clone()));
    }
    run_compile_test(name, &test, Language::Cxx, None);
}

fn test_dir(name: &'static str, filename: &'static str) {
//    unimplemented!()
}

macro_rules! test_file {
    ($name:ident, $file:tt) => {
        #[test]
        fn $name() {
            test_file(stringify!($name), $file);
        }
    }
}

macro_rules! test_dir {
    ($name:ident, $file:tt) => {
        #[test]
        fn $name() {
            test_dir(stringify!($name), $file);
        }
    }
}
// This file is generated by build.rs
include!(concat!(env!("OUT_DIR"), "/tests.rs"));
